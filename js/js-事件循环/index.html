<!DOCTYPE html>
<html lang="js">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/myicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/myicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yummyx02.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="js—事件循环（宏、微任务） 一、事件循环的出现 请注意：在js中，所有的异步任务都是放到事件循环队列中等待执行栈来调用，没有单独的线程 众所周知，js是单线程语言，同一时间只能处理一件事情，为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，Event Loop （事件循环）应运而生 那么，什么是事件循环呢？（浏览器">
<meta property="og:type" content="article">
<meta property="og:title" content="js-事件循环">
<meta property="og:url" content="https://yummyx02.github.io/js/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/index.html">
<meta property="og:site_name" content="Struggle in my life">
<meta property="og:description" content="js—事件循环（宏、微任务） 一、事件循环的出现 请注意：在js中，所有的异步任务都是放到事件循环队列中等待执行栈来调用，没有单独的线程 众所周知，js是单线程语言，同一时间只能处理一件事情，为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，Event Loop （事件循环）应运而生 那么，什么是事件循环呢？（浏览器">
<meta property="og:locale">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/02/OFZjzT.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/02/OFmp1f.jpg">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fca3d06b2464ce5a6694e0966fa93ff~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22997e327c5d4defaaa1ee4aa264ad4b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd424a6a6443420ba545a3a2467164c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c556ffd21edb47579088a6eaebf34c54~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp">
<meta property="article:published_time" content="2022-05-04T09:27:36.000Z">
<meta property="article:modified_time" content="2022-05-04T09:27:36.000Z">
<meta property="article:author" content="王翔_x">
<meta property="article:tag" content="js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/05/02/OFZjzT.jpg">


<link rel="canonical" href="https://yummyx02.github.io/js/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"js","comments":true,"permalink":"https://yummyx02.github.io/js/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","path":"js/js-事件循环/","title":"js-事件循环"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>js-事件循环 | Struggle in my life</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Struggle in my life</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">王翔的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>Links</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">js—事件循环（宏、微任务）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="nav-number">1.1.</span> <span class="nav-text">一、事件循环的出现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.1.1.</span> <span class="nav-text">二、宏任务和微任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.2.</span> <span class="nav-text">运行机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-js%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88%E4%BA%86%E8%A7%A3"><span class="nav-number">1.1.3.</span> <span class="nav-text">Node.js的事件循环（了解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">（1）事件循环的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">（2）事件循环的流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">（3）宏任务和微任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89process-nextTick"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">（4）process.nextTick()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885%EF%BC%89setImmediate-%E5%92%8C-setTimeout"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">（5）setImmediate 和 setTimeout</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Node%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8Event-Loop%E5%B7%AE%E5%BC%82"><span class="nav-number">1.1.4.</span> <span class="nav-text">4. Node与浏览器Event Loop差异</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="王翔_x"
      src="/images/avl.jpg">
  <p class="site-author-name" itemprop="name">王翔_x</p>
  <div class="site-description" itemprop="description">It's an IT blog...</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yummyX02" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yummyX02" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1245191297@qq.com" title="E-Mail → 1245191297@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
      
      
        <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
        <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
        <div class="widget-wrap">
          <h3 class="widget-title">Tag Cloud</h3>
    <div id="myCanvasContainer" class="widget tagcloud">
            <canvas width="250" height="250" id="resCanvas" style="width:100%">
              <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yolo/" rel="tag">Yolo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/machineing/" rel="tag">machineing</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vs-code/" rel="tag">vs code</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E9%A1%B9/" rel="tag">杂项</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a><span class="tag-list-count">1</span></li></ul>
            </canvas>
          </div>
        </div>
      
      
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="js">
    <link itemprop="mainEntityOfPage" href="https://yummyx02.github.io/js/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avl.jpg">
      <meta itemprop="name" content="王翔_x">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Struggle in my life">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="js-事件循环 | Struggle in my life">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          js-事件循环
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-04 17:27:36" itemprop="dateCreated datePublished" datetime="2022-05-04T17:27:36+08:00">2022-05-04</time>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>6.8k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>6 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1>js—事件循环（宏、微任务）</h1>
<h2 id="一、事件循环的出现">一、事件循环的出现</h2>
<p><strong>请注意：在js中，所有的异步任务都是放到事件循环队列中等待执行栈来调用，没有单独的线程</strong></p>
<p>众所周知，js是单线程语言，同一时间只能处理一件事情，为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，Event Loop （事件循环）应运而生</p>
<p>那么，什么是事件循环呢？（浏览器</p>
<span id="more"></span>
<blockquote>
<p>事件循环即为：浏览器的 js 引擎 中等待任务，执行任务，进入休眠状态等待更多任务这几个状态之间转换的无限循环。</p>
<p>你可以将它理解成一个算法。这个算法要完成的功能就是将上面的任务完成</p>
</blockquote>
<ul>
<li>
<p>JS分为同步任务和异步任务</p>
</li>
<li>
<p>同步任务都在主线程上执行，形成一个执行栈</p>
</li>
<li>
<p>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</p>
</li>
<li>
<p>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行</p>
<blockquote>
<p>同步任务：</p>
<p>直接输出的console.log()函数、new 的 promise函数</p>
<p>异步任务：</p>
<p>setTimeout setInterval  XMLHttpRequest（也就是 Ajax）</p>
</blockquote>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OFZjzT"><img src="https://s1.ax1x.com/2022/05/02/OFZjzT.jpg" alt="OFZjzT.jpg"></a></p>
<h3 id="二、宏任务和微任务">二、宏任务和微任务</h3>
<blockquote></blockquote>
<ul>
<li>宏任务：</li>
</ul>
<p>(macro)task，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</p>
<p>浏览器为了能够使得JS内部(macro)task与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(macro)task-&gt;渲染-&gt;(macro)task-&gt;...</span><br></pre></td></tr></table></figure>
<p><strong>宏任务包含</strong>：</p>
<p><strong>注意：关于 setTimeout 要补充的是，即便主线程为空，0 毫秒实际上也是达不到的。根据 HTML 的标准，最低是 4 毫秒。</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script(整体代码)</span><br><span class="line">setTimeout</span><br><span class="line">setInterval</span><br><span class="line">I/O</span><br><span class="line">UI交互事件</span><br><span class="line">postMessage</span><br><span class="line">MessageChannel</span><br><span class="line">setImmediate(Node.js 环境)</span><br></pre></td></tr></table></figure>
<ul>
<li>微任务</li>
</ul>
<p>microtask,可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。</p>
<p>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。</p>
<p><strong>微任务包含</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.then</span><br><span class="line">Object.observe</span><br><span class="line">MutationObserver</span><br><span class="line">process.nextTick(Node.js 环境)</span><br></pre></td></tr></table></figure>
<h3 id="运行机制">运行机制</h3>
<p>在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：</p>
<ul>
<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>
<li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是说：一次<span class="keyword">Event</span> <span class="keyword">Loop</span>循环会处理一个宏任务 和所有这次循环中产生的微任务</span><br></pre></td></tr></table></figure>
<p>如图：<a target="_blank" rel="noopener" href="https://imgtu.com/i/OFmp1f"><img src="https://s1.ax1x.com/2022/05/02/OFmp1f.jpg" alt="OFmp1f.jpg"></a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;同步代码1&#x27;</span>);<span class="comment">//同步任务 率先执行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)<span class="comment">// 异步任务的宏任务</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;同步代码2&#x27;</span>)<span class="comment">//同步任务</span></span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise.then&#x27;</span>)<span class="comment">//异步任务的微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;同步代码3&#x27;</span>);<span class="comment">//同步任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">同步代码1</span></span><br><span class="line"><span class="comment">同步代码2</span></span><br><span class="line"><span class="comment">同步代码3</span></span><br><span class="line"><span class="comment">promise.then</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先执行宏任务：整体的script代码，输出同步代码1</span></span><br><span class="line"><span class="comment">遇到setTimeout函数，将其加入到setTimeut宏任务队列中</span></span><br><span class="line"><span class="comment">遇到 promise.then()，加入微任务，当前微任务队列(promise)</span></span><br><span class="line"><span class="comment">然后输出 同步代码2</span></span><br><span class="line"><span class="comment">接着输出 同步任务3 此时，宏任务执行完毕</span></span><br><span class="line"><span class="comment">开始执行微任务promise 输出 : promise.then</span></span><br><span class="line"><span class="comment">待微任务执行完毕后继续执行新的宏任务 即：setTimeout宏任务</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先，执行异步操作async function （其本质为将await后面的操作封装为promise的resolver 里，因此会发生阻塞）打印async1 start</span></span><br><span class="line"><span class="comment">接着执行async2() 打印async2</span></span><br><span class="line"><span class="comment">然后遇到setTimeout 异步操作 放进宏任务</span></span><br><span class="line"><span class="comment">接着遇到promise 同步执行打印promise1 遇到reserve（）放进微任务队列中</span></span><br><span class="line"><span class="comment">同步执行完script end 本次宏任务执行完毕 执行微任务，根据队列的先进先出原则 打印 async1 end  接着进入promise微任务 打印promise2</span></span><br><span class="line"><span class="comment">接着 循环执行 setTimeout 宏任务 打印timeout</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">result:</span></span><br><span class="line"><span class="comment">async1 start</span></span><br><span class="line"><span class="comment"> async2</span></span><br><span class="line"><span class="comment"> promise1</span></span><br><span class="line"><span class="comment"> script end</span></span><br><span class="line"><span class="comment"> async1 end</span></span><br><span class="line"><span class="comment"> promise2</span></span><br><span class="line"><span class="comment"> timeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">写在后面：</span><br><span class="line"></span><br><span class="line">**<span class="string">&quot;任务队列&quot;</span>是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在<span class="string">&quot;任务队列&quot;</span>中添加一个事件，表示相关的异步任务可以进入<span class="string">&quot;执行栈&quot;</span>了**。主线程读取<span class="string">&quot;任务队列&quot;</span>，就是读取里面有哪些事件。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;任务队列&quot;</span>是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，<span class="string">&quot;任务队列&quot;</span>上第一位的事件就自动进入主线程。但是，由于存在后文提到的<span class="string">&quot;定时器&quot;</span>功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</span><br><span class="line"></span><br><span class="line"><span class="keyword">JavaScript中没有任何代码时立即执行的，都是进程空闲时尽快执行</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure>
<h3 id="Node-js的事件循环（了解">Node.js的事件循环（了解</h3>
<h4 id="（1）事件循环的概念">（1）事件循环的概念</h4>
<p>对于Node.js的事件循环，官网的描述如下：</p>
<blockquote>
<p>When Node.js starts, it initializes the event loop, processes the provided input script (or drops into the <a href="https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2Fapi%2Frepl.html%23repl_repl">REPL</a>, which is not covered in this document) which may make async API calls, schedule timers, or call <code>process.nextTick()</code>, then begins processing the event loop.</p>
</blockquote>
<p>翻译一下就是：当Node.js启动时，它会初始化一个事件循环，来处理输入的脚本，这个脚本可能进行异步API的调用、调度计时器或调用process.nextTick()，然后开始处理事件循环。</p>
<p>JavaScript和Node.js是基于V8 引擎的，浏览器中包含的异步方式在 NodeJS 中也是一样的。除此之外，Node.js中还有一些其他的异步形式：</p>
<ul>
<li>文件 I/O：异步加载本地文件。</li>
<li>setImmediate()：与 setTimeout 设置 0ms 类似，在某些同步任务完成后立马执行。</li>
<li>process.nextTick()：在某些同步任务完成后立马执行。</li>
<li>server.close、socket.on(‘close’,…）等：关闭回调。</li>
</ul>
<p>这些异步任务的执行就需要依靠Node.js的事件循环机制了。</p>
<p>Node.js 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js使用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现的，如下图所示： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fca3d06b2464ce5a6694e0966fa93ff~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"> 根据上图，可以看到Node.js的运行机制如下:</p>
<ol>
<li>V8引擎负责解析JavaScript脚本；</li>
<li>解析后的代码，调用Node API；</li>
<li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎；</li>
<li>V8引擎将结果返回给用户；</li>
</ol>
<h4 id="（2）事件循环的流程">（2）事件循环的流程</h4>
<p>其中libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。下面 是Eventloop 事件循环的流程：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22997e327c5d4defaaa1ee4aa264ad4b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="事件循环-第 2 页.png"></p>
<p>整个流程分为六个阶段，当这六个阶段执行完一次之后，才可以算得上执行了一次 Eventloop 的循环过程。下面来看下这六个阶段都做了哪些事：</p>
<ol>
<li><code>timers</code> 阶段：执行timer（setTimeout、setInterval）的回调，由 poll 阶段控制；</li>
<li><code>I/O callbacks</code> 阶段：主要执行系统级别的回调函数，比如 TCP 连接失败的回调；</li>
<li><code>idle, prepare</code> 阶段：仅Node.js内部使用，可以忽略；</li>
<li><code>poll</code> 阶段：轮询等待新的链接和请求等事件，执行 I/O 回调等；</li>
<li><code>check</code> 阶段：执行 setImmediate() 的回调；</li>
<li><code>close callbacks</code> 阶段：执行关闭请求的回调函数，比如socket.on(‘close’, …)</li>
</ol>
<p>注意：上面每个阶段都会去执行完当前阶段的任务队列，然后继续执行当前阶段的微任务队列，只有当前阶段所有微任务都执行完了，才会进入下个阶段，这里也是与浏览器中逻辑差异较大的地方。</p>
<p>其中，这里面比较重要的就是第四阶段：poll，这一阶段中，系统主要做两件事：</p>
<ul>
<li>回到 timer 阶段执行回调</li>
<li>执行 I/O 回调</li>
</ul>
<p>在进入该阶段时如果没有设定了 timer 的话，会出现以下情况：</p>
<p>（1）如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制；</p>
<p>（2）如果 poll 队列为空时，会出现以下情况：</p>
<ul>
<li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调；</li>
<li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去；</li>
</ul>
<p>当设定了 timer 且 poll 队列为空，则会判断是否有 timer 超时，如果有的就会回到 timer 阶段执行回调。</p>
<p>这一过程的具体执行流程如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd424a6a6443420ba545a3a2467164c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p>
<h4 id="（3）宏任务和微任务">（3）宏任务和微任务</h4>
<p>Node.js事件循环的异步队列也分为两种：宏任务队列和微任务队列。</p>
<ul>
<li>常见的宏任务：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等。</li>
<li>常见的微任务：process.nextTick、new Promise().then(回调)等。</li>
</ul>
<h4 id="（4）process-nextTick">（4）process.nextTick()</h4>
<p>上面提到了process.nextTick()，它是node中新引入的一个任务队列，它会在上述各个阶段结束时，在进入下一个阶段之前立即执行。</p>
<p>Node.js官方文档的解释如下：</p>
<blockquote>
<p>process.nextTick()is not technically part of the event loop. Instead, thenextTickQueuewill be processed after the current operation is completed, regardless of the current phase of the event loop. Here, an operation is defined as a transition from the underlying C/C++ handler, and handling the JavaScript that needs to be executed.</p>
</blockquote>
<p>例如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&#x27;promise&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nextTick</span><br><span class="line">promise</span><br><span class="line">timeout</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>可以看到，process.nextTick()是优先于promise的回调执行。</p>
<h4 id="（5）setImmediate-和-setTimeout">（5）setImmediate 和 setTimeout</h4>
<p>上面还提到了setImmediate 和 setTimeout，这两者很相似，主要区别在于调用时机的不同：</p>
<ul>
<li><strong>setImmediate</strong>：在poll阶段完成时执行，即check阶段；</li>
<li><strong>setTimeout</strong>：在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行；</li>
</ul>
<p>例如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timeout</span><br><span class="line">setImmediate</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>在上面代码的执行过程中，第一轮循环后，分别将 setTimeout  和 setImmediate 加入了各自阶段的任务队列。第二轮循环首先进入<strong>timers 阶段</strong>，执行定时器队列回调，然后 <strong>pending callbacks</strong>和<strong>poll 阶段</strong>没有任务，因此进入<strong>check 阶段</strong>执行 setImmediate 回调。所以最后输出为timeout、setImmediate。</p>
<h3 id="4-Node与浏览器Event-Loop差异">4. <strong>Node与浏览器Event Loop差异</strong></h3>
<p>Node.js与浏览器的 Event Loop 差异如下：</p>
<ul>
<li>Node.js：microtask 在事件循环的各个阶段之间执行；</li>
<li>浏览器：microtask 在事件循环的 macrotask 执行完之后执行；</li>
</ul>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fraw.githubusercontent.com%2FXQY279%2Fblog%2Fmaster%2Fimage%2Fdiff.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c556ffd21edb47579088a6eaebf34c54~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></a> Nodejs和浏览器的事件循环流程对比如下：</p>
<ol>
<li>执行全局的 Script 代码（与浏览器无差）；</li>
<li>把微任务队列清空：注意，Node 清空微任务队列的手法比较特别。在浏览器中，我们只有一个微任务队列需要接受处理；但在 Node 中，有两类微任务队列：next-tick 队列和其它队列。其中这个 next-tick 队列，专门用来收敛 process.nextTick 派发的异步任务。<strong>在清空队列时，优先清空 next-tick 队列中的任务，随后才会清空其它微任务</strong>；</li>
<li>开始执行 macro-task（宏任务）。注意，Node 执行宏任务的方式与浏览器不同：在浏览器中，我们每次出队并执行一个宏任务；而在 Node 中，我们每次会尝试清空当前阶段对应宏任务队列里的所有任务（除非达到系统限制）；</li>
<li>步骤3开始，会进入 3 -&gt; 2 -&gt; 3 -&gt; 2…的循环。</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/js/" rel="tag"><i class="fa fa-tag"></i> js</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/js/js-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/" rel="prev" title="js-同步和异步">
                  <i class="fa fa-chevron-left"></i> js-同步和异步
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/C++/C-%E2%80%94%E2%80%94%E4%B8%89%E7%A7%8D%E7%BB%A7%E6%89%BF%E5%92%8C%E6%9E%84%E9%80%A0-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" rel="next" title="C++——三种继承和构造/析构函数">
                  C++——三种继承和构造/析构函数 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王翔_x</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">70k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">1:03</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"yummyX02/yummyX02.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
